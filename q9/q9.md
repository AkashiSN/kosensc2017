# Weak RSA2 [Crypto / 300pt]

## Question
Same modulo, different key.
That means...?

```plain
N=15620594388031266473712197182475401349767058475004272224536225648625952854897365941672814814279333073858254829580868738008914764200900970816497912510360543912576564493343805445025709928720849734646456324926157789117630436365389163740755803508552528581884072989427047817466199091956971202594169215137811755824226260563197033762229828516931685661716640702851860618004147473654194699872663323713081865134559047690101137746846052872766057239471941861178242802245323235655974041818544934629078008209255370053896111737087831087011650112842648525928751876926708669947901109909413734984869911340235105269214508784024367437953
e1=65537
e2=65539
c1=1489339754254835944677817314156282333390420547822585047855038563837425349664194850427115746596887213776055939099564558606337055512116152708397846771996964510378668840230909565544664963310261652925078679498650790381754626497493158792557390482082573480212247709568460489056108142552816301497747321257232440135839929603826233477775774821500965278201630483068367395608986530462394069768248345356496649844524484174543476759824253644298849853595634079532089280524931251869742857752978697126429863924143953454746075801930602577660175830635621109439756450373000808212559121842164656100986032352919953870573034007586691572423
c2=8937852908134130987306629574212610585870355427149438575409310990721292816465794336063622070701241632165975343736107666017483999564028889523529815370891549255738484538948306769705294545796448878619345994465089208610331683024233794031754249094350901527624987088546851077662835034720521633888549528955396181369564105250206441938210096873324891523699556663493825747077759200653146111288180531806191004735381569983983004774687680500543972478695930507359686485047486651425834899677627088843750201678265731343452734974295913237386547145723229171516297836237470372655702578565577725744629493384561781549781547455844816880977
```

## Answer

解答者: [@yfba_](https://twitter.com/yfba_)

> Same modulo, different key.

とのことなので、

> [公開鍵暗号 - RSA - 基礎](http://elliptic-shiho.hatenablog.com/entry/2015/11/12/182219)
>
>Common Modulus Attack
>
>m, nが共通、eが異なる幾つかのe, n, cの組がある時、mを計算することができる攻撃。

であるとわかる

[公開鍵暗号 RSA - Common Modulus Attack, 秘密鍵からの素因数分解](http://elliptic-shiho.hatenablog.com/entry/2015/12/14/043745)
>### Common Modulus Attack
> RSA公開鍵(n,e1), (n,e2)と平文m、

> それぞれの公開鍵で暗号化した暗号文c1,c2があり、

> gcd(e1,e2)=1の時、n,e1,e2,c1,c2から平文mを導出することができる。

[RSA cracking: The same message is sent to two different people problem](https://crypto.stackexchange.com/questions/1614/rsa-cracking-the-same-message-is-sent-to-two-different-people-problem)

同じような問題があったので

いい感じにコードを書いてやる

```python
#!/usr/bin/env python2
# Common Modulus Attack

#http://anh.cs.luc.edu/331/code/xgcd.py
def gcd(a,b):
    """Returns the gcd of its inputs times the sign of b if b is nonzero,
    and times the sign of a if b is 0.
    """
    while b != 0:
      a,b = b, a % b
    return a

#http://anh.cs.luc.edu/331/code/xgcd.py
def xgcd(a,b):
    """Extended GCD:
    Returns (gcd, x, y) where gcd is the greatest common divisor of a and b
    with the sign of b if b is nonzero, and with the sign of a if b is 0.
    The numbers x,y are such that gcd = ax+by."""
    prevx, x = 1, 0;  prevy, y = 0, 1
    while b:
        q, r = divmod(a,b)
        x, prevx = prevx - q*x, x  
        y, prevy = prevy - q*y, y
        a, b = b, r
    return a, prevx, prevy

#https://stackoverflow.com/questions/4798654/modular-multiplicative-inverse-function-in-python
# a is the number you want the inverse for
# b is the modulus
def mod_inverse(a, b):
    r = -1
    B = b
    A = a
    eq_set = []
    full_set = []
    mod_set = []

    #euclid's algorithm
    while r!=1 and r!=0:
        r = b%a
        q = b//a
        eq_set = [r, b, a, q*-1]
        b = a
        a = r
        full_set.append(eq_set)

    for i in range(0, 4):
        mod_set.append(full_set[-1][i])

    mod_set.insert(2, 1)
    counter = 0

    #extended euclid's algorithm
    for i in range(1, len(full_set)):
        if counter%2 == 0:
            mod_set[2] = full_set[-1*(i+1)][3]*mod_set[4]+mod_set[2]
            mod_set[3] = full_set[-1*(i+1)][1]

        elif counter%2 != 0:
            mod_set[4] = full_set[-1*(i+1)][3]*mod_set[2]+mod_set[4]
            mod_set[1] = full_set[-1*(i+1)][1]

        counter += 1

    if mod_set[3] == B:
        return mod_set[2]%B
    return mod_set[4]%B

def pow_mod(base, exp, mod):
    n = base % mod
    rem = []
    while exp >= 2:
        r = exp % 2
        exp //= 2
        if r == 1:
            rem.append(n)

        n = (n*n) % mod
    for x in rem:
        n = (n * x) % mod

    return n

if __name__ == '__main__':
    n=15620594388031266473712197182475401349767058475004272224536225648625952854897365941672814814279333073858254829580868738008914764200900970816497912510360543912576564493343805445025709928720849734646456324926157789117630436365389163740755803508552528581884072989427047817466199091956971202594169215137811755824226260563197033762229828516931685661716640702851860618004147473654194699872663323713081865134559047690101137746846052872766057239471941861178242802245323235655974041818544934629078008209255370053896111737087831087011650112842648525928751876926708669947901109909413734984869911340235105269214508784024367437953
    e1=65537
    e2=65539
    c1=1489339754254835944677817314156282333390420547822585047855038563837425349664194850427115746596887213776055939099564558606337055512116152708397846771996964510378668840230909565544664963310261652925078679498650790381754626497493158792557390482082573480212247709568460489056108142552816301497747321257232440135839929603826233477775774821500965278201630483068367395608986530462394069768248345356496649844524484174543476759824253644298849853595634079532089280524931251869742857752978697126429863924143953454746075801930602577660175830635621109439756450373000808212559121842164656100986032352919953870573034007586691572423
    c2=8937852908134130987306629574212610585870355427149438575409310990721292816465794336063622070701241632165975343736107666017483999564028889523529815370891549255738484538948306769705294545796448878619345994465089208610331683024233794031754249094350901527624987088546851077662835034720521633888549528955396181369564105250206441938210096873324891523699556663493825747077759200653146111288180531806191004735381569983983004774687680500543972478695930507359686485047486651425834899677627088843750201678265731343452734974295913237386547145723229171516297836237470372655702578565577725744629493384561781549781547455844816880977
     
    val = xgcd(e1,e2)

    if val[1] < 0:
        a = -val[1]
        b = val[2]
        c1_inv = mod_inverse(c1,n)
        c1a = pow_mod(c1_inv, a, n)
        c2b = pow_mod(c2, b, n)
    else:
        a = val[1]
        b = -val[2]
        c2_inv = mod_inverse(c2,n)
        c1a = pow_mod(c1, a, n)
        c2b = pow_mod(c2_inv, b, n)

    m = (c1a * c2b)%n

    print(hex(m)[2:-1:].decode('hex'))
```

実行してフラグを得る

```bash
$  python q9.py
SCKOSEN{Comm0n_Modu1us_d1ff3rent_pubkey_1s_n0t_s4fe}
```

`SCKOSEN{Comm0n_Modu1us_d1ff3rent_pubkey_1s_n0t_s4fe}`